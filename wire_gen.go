// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/go-redis/redis/v8"
	"gopkg.in/yaml.v2"
	"learn.ratelimiter/api"
	"learn.ratelimiter/config"
	"learn.ratelimiter/metrics"
	"learn.ratelimiter/middleware"
	"log"
	"os"
	"time"
)

// Injectors from wire.go:

// The Injector function declaration.
// This tells Wire what top-level components we want to build.
func InitializeApplication() (*application, error) {
	factory := provideLimiterFactory()
	limiterConfig, err := provideLimiterConfig()
	if err != nil {
		return nil, err
	}
	client, err := provideRedisClient(limiterConfig)
	if err != nil {
		return nil, err
	}
	backendClients := provideBackendClients(client)
	limiter, err := provideLimiter(factory, limiterConfig, backendClients)
	if err != nil {
		return nil, err
	}
	rateLimitMetrics := provideMetrics()
	rateLimitMiddleware := provideRateLimitMiddleware(limiter, rateLimitMetrics)
	mainApplication := &application{
		RateLimiterMiddleware: rateLimitMiddleware,
		Metrics:               rateLimitMetrics,
	}
	return mainApplication, nil
}

// wire.go:

// loadConfig reads the configuration from a YAML file.
// This function needs to be accessible to the wire providers.
func loadConfig(filepath string) (*config.LimiterConfig, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var cfg struct {
		Limiter config.LimiterConfig `yaml:"limiter"`
	}
	err = yaml.Unmarshal(data, &cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	return &cfg.Limiter, nil
}

func provideLimiterConfig() (*config.LimiterConfig, error) {
	return loadConfig("config.yaml")
}

func provideRedisClient(cfg *config.LimiterConfig) (*redis.Client, error) {
	if cfg.Backend != config.Redis {
		return nil, nil
	}
	if cfg.RedisParams == nil {
		return nil, fmt.Errorf("redis backend selected but redis_params are missing")
	}
	client := redis.NewClient(&redis.Options{
		Addr:     cfg.RedisParams.Address,
		Password: cfg.RedisParams.Password,
		DB:       cfg.RedisParams.DB,
	})
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_, err := client.Ping(ctx).Result()
	if err != nil {
		return nil, fmt.Errorf("failed to connect to Redis: %w", err)
	}
	log.Println("Connected to Redis successfully via Wire provider")
	return client, nil
}

func provideBackendClients(redisClient *redis.Client) api.BackendClients {
	return api.BackendClients{
		RedisClient: redisClient,
	}
}

func provideLimiterFactory() *api.Factory {
	return api.NewFactory()
}

func provideLimiter(factory *api.Factory, cfg *config.LimiterConfig, clients api.BackendClients) (api.Limiter, error) {
	return factory.CreateLimiter(*cfg, clients)
}

func provideMetrics() *metrics.RateLimitMetrics {
	return metrics.NewRateLimitMetrics()
}

func provideRateLimitMiddleware(limiter api.Limiter, metrics2 *metrics.RateLimitMetrics) *middleware.RateLimitMiddleware {

	return middleware.NewRateLimitMiddleware(limiter, metrics2)
}
